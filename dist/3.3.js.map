{"version":3,"sources":["webpack:///3.3.js","webpack:///./~/.0.1.3@html5-image-compress/src/libs/exif.js"],"names":["webpackJsonp","697","module","exports","__webpack_require__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","imageHasData","img","base64ToArrayBuffer","base64","contentType","match","replace","binary","atob","len","length","buffer","ArrayBuffer","view","Uint8Array","i","charCodeAt","objectURLToBlob","url","callback","http","XMLHttpRequest","open","responseType","onload","e","this","status","response","send","getImageData","handleBinaryFile","binFile","data","findEXIFinJPEG","iptcdata","findIPTCinJPEG","exifdata","call","src","test","arrayBuffer","fileReader","FileReader","target","result","blob","readAsArrayBuffer","window","Blob","File","debug","console","log","byteLength","file","dataView","DataView","getUint8","marker","offset","readEXIFData","getUint16","isFieldSegmentStart","nameHeaderLength","startOffset","sectionLength","readIPTCData","fieldValue","fieldName","dataSize","segmentType","segmentSize","segmentStartPos","IptcFieldMap","getInt16","getStringFromDB","hasOwnProperty","Array","push","readTags","tiffStart","dirStart","strings","bigEnd","entryOffset","tag","entries","tags","readTagValue","vals","val","n","numerator","denominator","type","numValues","getUint32","valueOffset","Number","getInt32","start","outstr","String","fromCharCode","exifData","gpsData","tiffOffset","firstIFDOffset","TiffTags","ExifIFDPointer","ExifTags","StringValues","Components","GPSInfoIFDPointer","GPSTags","EXIF","obj","EXIFwrapped","Tags","36864","40960","40961","40962","40963","37121","37122","37500","37510","40964","36867","36868","37520","37521","37522","33434","33437","34850","34852","34855","34856","37377","37378","37379","37380","37381","37382","37383","37384","37385","37396","37386","41483","41484","41486","41487","41488","41492","41493","41495","41728","41729","41730","41985","41986","41987","41988","41989","41990","41991","41992","41993","41994","41995","41996","40965","42016","256","257","34665","34853","258","259","262","274","277","284","530","531","282","283","296","273","278","279","513","514","301","318","319","529","532","306","270","271","272","305","315","33432","0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","ExposureProgram","MeteringMode","255","LightSource","Flash","31","32","65","69","71","73","77","79","89","93","95","SensingMethod","SceneCaptureType","SceneType","CustomRendered","WhiteBalance","GainControl","Contrast","Saturation","Sharpness","SubjectDistanceRange","FileSource","120","110","55","80","85","122","105","116","getData","Image","HTMLImageElement","complete","getTag","getAllTags","a","pretty","strPretty","readFromBinaryFile","apply","undefined"],"mappings":"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","file":"3.3.js?v=fb5f58f6093cfaae2ffa","sourcesContent":["webpackJsonp([3],{\n\n/***/ 697:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n\t\n\t    var debug = false;\n\t\n\t    var root = this;\n\t\n\t    var EXIF = function(obj) {\n\t        if (obj instanceof EXIF) return obj;\n\t        if (!(this instanceof EXIF)) return new EXIF(obj);\n\t        this.EXIFwrapped = obj;\n\t    };\n\t\n\t    if (true) {\n\t        if (typeof module !== 'undefined' && module.exports) {\n\t            exports = module.exports = EXIF;\n\t        }\n\t        exports.EXIF = EXIF;\n\t    } else {\n\t        root.EXIF = EXIF;\n\t    }\n\t\n\t    var ExifTags = EXIF.Tags = {\n\t\n\t        // version tags\n\t        0x9000 : \"ExifVersion\",             // EXIF version\n\t        0xA000 : \"FlashpixVersion\",         // Flashpix format version\n\t\n\t        // colorspace tags\n\t        0xA001 : \"ColorSpace\",              // Color space information tag\n\t\n\t        // image configuration\n\t        0xA002 : \"PixelXDimension\",         // Valid width of meaningful image\n\t        0xA003 : \"PixelYDimension\",         // Valid height of meaningful image\n\t        0x9101 : \"ComponentsConfiguration\", // Information about channels\n\t        0x9102 : \"CompressedBitsPerPixel\",  // Compressed bits per pixel\n\t\n\t        // user information\n\t        0x927C : \"MakerNote\",               // Any desired information written by the manufacturer\n\t        0x9286 : \"UserComment\",             // Comments by user\n\t\n\t        // related file\n\t        0xA004 : \"RelatedSoundFile\",        // Name of related sound file\n\t\n\t        // date and time\n\t        0x9003 : \"DateTimeOriginal\",        // Date and time when the original image was generated\n\t        0x9004 : \"DateTimeDigitized\",       // Date and time when the image was stored digitally\n\t        0x9290 : \"SubsecTime\",              // Fractions of seconds for DateTime\n\t        0x9291 : \"SubsecTimeOriginal\",      // Fractions of seconds for DateTimeOriginal\n\t        0x9292 : \"SubsecTimeDigitized\",     // Fractions of seconds for DateTimeDigitized\n\t\n\t        // picture-taking conditions\n\t        0x829A : \"ExposureTime\",            // Exposure time (in seconds)\n\t        0x829D : \"FNumber\",                 // F number\n\t        0x8822 : \"ExposureProgram\",         // Exposure program\n\t        0x8824 : \"SpectralSensitivity\",     // Spectral sensitivity\n\t        0x8827 : \"ISOSpeedRatings\",         // ISO speed rating\n\t        0x8828 : \"OECF\",                    // Optoelectric conversion factor\n\t        0x9201 : \"ShutterSpeedValue\",       // Shutter speed\n\t        0x9202 : \"ApertureValue\",           // Lens aperture\n\t        0x9203 : \"BrightnessValue\",         // Value of brightness\n\t        0x9204 : \"ExposureBias\",            // Exposure bias\n\t        0x9205 : \"MaxApertureValue\",        // Smallest F number of lens\n\t        0x9206 : \"SubjectDistance\",         // Distance to subject in meters\n\t        0x9207 : \"MeteringMode\",            // Metering mode\n\t        0x9208 : \"LightSource\",             // Kind of light source\n\t        0x9209 : \"Flash\",                   // Flash status\n\t        0x9214 : \"SubjectArea\",             // Location and area of main subject\n\t        0x920A : \"FocalLength\",             // Focal length of the lens in mm\n\t        0xA20B : \"FlashEnergy\",             // Strobe energy in BCPS\n\t        0xA20C : \"SpatialFrequencyResponse\",    //\n\t        0xA20E : \"FocalPlaneXResolution\",   // Number of pixels in width direction per FocalPlaneResolutionUnit\n\t        0xA20F : \"FocalPlaneYResolution\",   // Number of pixels in height direction per FocalPlaneResolutionUnit\n\t        0xA210 : \"FocalPlaneResolutionUnit\",    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\n\t        0xA214 : \"SubjectLocation\",         // Location of subject in image\n\t        0xA215 : \"ExposureIndex\",           // Exposure index selected on camera\n\t        0xA217 : \"SensingMethod\",           // Image sensor type\n\t        0xA300 : \"FileSource\",              // Image source (3 == DSC)\n\t        0xA301 : \"SceneType\",               // Scene type (1 == directly photographed)\n\t        0xA302 : \"CFAPattern\",              // Color filter array geometric pattern\n\t        0xA401 : \"CustomRendered\",          // Special processing\n\t        0xA402 : \"ExposureMode\",            // Exposure mode\n\t        0xA403 : \"WhiteBalance\",            // 1 = auto white balance, 2 = manual\n\t        0xA404 : \"DigitalZoomRation\",       // Digital zoom ratio\n\t        0xA405 : \"FocalLengthIn35mmFilm\",   // Equivalent foacl length assuming 35mm film camera (in mm)\n\t        0xA406 : \"SceneCaptureType\",        // Type of scene\n\t        0xA407 : \"GainControl\",             // Degree of overall image gain adjustment\n\t        0xA408 : \"Contrast\",                // Direction of contrast processing applied by camera\n\t        0xA409 : \"Saturation\",              // Direction of saturation processing applied by camera\n\t        0xA40A : \"Sharpness\",               // Direction of sharpness processing applied by camera\n\t        0xA40B : \"DeviceSettingDescription\",    //\n\t        0xA40C : \"SubjectDistanceRange\",    // Distance to subject\n\t\n\t        // other tags\n\t        0xA005 : \"InteroperabilityIFDPointer\",\n\t        0xA420 : \"ImageUniqueID\"            // Identifier assigned uniquely to each image\n\t    };\n\t\n\t    var TiffTags = EXIF.TiffTags = {\n\t        0x0100 : \"ImageWidth\",\n\t        0x0101 : \"ImageHeight\",\n\t        0x8769 : \"ExifIFDPointer\",\n\t        0x8825 : \"GPSInfoIFDPointer\",\n\t        0xA005 : \"InteroperabilityIFDPointer\",\n\t        0x0102 : \"BitsPerSample\",\n\t        0x0103 : \"Compression\",\n\t        0x0106 : \"PhotometricInterpretation\",\n\t        0x0112 : \"Orientation\",\n\t        0x0115 : \"SamplesPerPixel\",\n\t        0x011C : \"PlanarConfiguration\",\n\t        0x0212 : \"YCbCrSubSampling\",\n\t        0x0213 : \"YCbCrPositioning\",\n\t        0x011A : \"XResolution\",\n\t        0x011B : \"YResolution\",\n\t        0x0128 : \"ResolutionUnit\",\n\t        0x0111 : \"StripOffsets\",\n\t        0x0116 : \"RowsPerStrip\",\n\t        0x0117 : \"StripByteCounts\",\n\t        0x0201 : \"JPEGInterchangeFormat\",\n\t        0x0202 : \"JPEGInterchangeFormatLength\",\n\t        0x012D : \"TransferFunction\",\n\t        0x013E : \"WhitePoint\",\n\t        0x013F : \"PrimaryChromaticities\",\n\t        0x0211 : \"YCbCrCoefficients\",\n\t        0x0214 : \"ReferenceBlackWhite\",\n\t        0x0132 : \"DateTime\",\n\t        0x010E : \"ImageDescription\",\n\t        0x010F : \"Make\",\n\t        0x0110 : \"Model\",\n\t        0x0131 : \"Software\",\n\t        0x013B : \"Artist\",\n\t        0x8298 : \"Copyright\"\n\t    };\n\t\n\t    var GPSTags = EXIF.GPSTags = {\n\t        0x0000 : \"GPSVersionID\",\n\t        0x0001 : \"GPSLatitudeRef\",\n\t        0x0002 : \"GPSLatitude\",\n\t        0x0003 : \"GPSLongitudeRef\",\n\t        0x0004 : \"GPSLongitude\",\n\t        0x0005 : \"GPSAltitudeRef\",\n\t        0x0006 : \"GPSAltitude\",\n\t        0x0007 : \"GPSTimeStamp\",\n\t        0x0008 : \"GPSSatellites\",\n\t        0x0009 : \"GPSStatus\",\n\t        0x000A : \"GPSMeasureMode\",\n\t        0x000B : \"GPSDOP\",\n\t        0x000C : \"GPSSpeedRef\",\n\t        0x000D : \"GPSSpeed\",\n\t        0x000E : \"GPSTrackRef\",\n\t        0x000F : \"GPSTrack\",\n\t        0x0010 : \"GPSImgDirectionRef\",\n\t        0x0011 : \"GPSImgDirection\",\n\t        0x0012 : \"GPSMapDatum\",\n\t        0x0013 : \"GPSDestLatitudeRef\",\n\t        0x0014 : \"GPSDestLatitude\",\n\t        0x0015 : \"GPSDestLongitudeRef\",\n\t        0x0016 : \"GPSDestLongitude\",\n\t        0x0017 : \"GPSDestBearingRef\",\n\t        0x0018 : \"GPSDestBearing\",\n\t        0x0019 : \"GPSDestDistanceRef\",\n\t        0x001A : \"GPSDestDistance\",\n\t        0x001B : \"GPSProcessingMethod\",\n\t        0x001C : \"GPSAreaInformation\",\n\t        0x001D : \"GPSDateStamp\",\n\t        0x001E : \"GPSDifferential\"\n\t    };\n\t\n\t    var StringValues = EXIF.StringValues = {\n\t        ExposureProgram : {\n\t            0 : \"Not defined\",\n\t            1 : \"Manual\",\n\t            2 : \"Normal program\",\n\t            3 : \"Aperture priority\",\n\t            4 : \"Shutter priority\",\n\t            5 : \"Creative program\",\n\t            6 : \"Action program\",\n\t            7 : \"Portrait mode\",\n\t            8 : \"Landscape mode\"\n\t        },\n\t        MeteringMode : {\n\t            0 : \"Unknown\",\n\t            1 : \"Average\",\n\t            2 : \"CenterWeightedAverage\",\n\t            3 : \"Spot\",\n\t            4 : \"MultiSpot\",\n\t            5 : \"Pattern\",\n\t            6 : \"Partial\",\n\t            255 : \"Other\"\n\t        },\n\t        LightSource : {\n\t            0 : \"Unknown\",\n\t            1 : \"Daylight\",\n\t            2 : \"Fluorescent\",\n\t            3 : \"Tungsten (incandescent light)\",\n\t            4 : \"Flash\",\n\t            9 : \"Fine weather\",\n\t            10 : \"Cloudy weather\",\n\t            11 : \"Shade\",\n\t            12 : \"Daylight fluorescent (D 5700 - 7100K)\",\n\t            13 : \"Day white fluorescent (N 4600 - 5400K)\",\n\t            14 : \"Cool white fluorescent (W 3900 - 4500K)\",\n\t            15 : \"White fluorescent (WW 3200 - 3700K)\",\n\t            17 : \"Standard light A\",\n\t            18 : \"Standard light B\",\n\t            19 : \"Standard light C\",\n\t            20 : \"D55\",\n\t            21 : \"D65\",\n\t            22 : \"D75\",\n\t            23 : \"D50\",\n\t            24 : \"ISO studio tungsten\",\n\t            255 : \"Other\"\n\t        },\n\t        Flash : {\n\t            0x0000 : \"Flash did not fire\",\n\t            0x0001 : \"Flash fired\",\n\t            0x0005 : \"Strobe return light not detected\",\n\t            0x0007 : \"Strobe return light detected\",\n\t            0x0009 : \"Flash fired, compulsory flash mode\",\n\t            0x000D : \"Flash fired, compulsory flash mode, return light not detected\",\n\t            0x000F : \"Flash fired, compulsory flash mode, return light detected\",\n\t            0x0010 : \"Flash did not fire, compulsory flash mode\",\n\t            0x0018 : \"Flash did not fire, auto mode\",\n\t            0x0019 : \"Flash fired, auto mode\",\n\t            0x001D : \"Flash fired, auto mode, return light not detected\",\n\t            0x001F : \"Flash fired, auto mode, return light detected\",\n\t            0x0020 : \"No flash function\",\n\t            0x0041 : \"Flash fired, red-eye reduction mode\",\n\t            0x0045 : \"Flash fired, red-eye reduction mode, return light not detected\",\n\t            0x0047 : \"Flash fired, red-eye reduction mode, return light detected\",\n\t            0x0049 : \"Flash fired, compulsory flash mode, red-eye reduction mode\",\n\t            0x004D : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\n\t            0x004F : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\n\t            0x0059 : \"Flash fired, auto mode, red-eye reduction mode\",\n\t            0x005D : \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\n\t            0x005F : \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\n\t        },\n\t        SensingMethod : {\n\t            1 : \"Not defined\",\n\t            2 : \"One-chip color area sensor\",\n\t            3 : \"Two-chip color area sensor\",\n\t            4 : \"Three-chip color area sensor\",\n\t            5 : \"Color sequential area sensor\",\n\t            7 : \"Trilinear sensor\",\n\t            8 : \"Color sequential linear sensor\"\n\t        },\n\t        SceneCaptureType : {\n\t            0 : \"Standard\",\n\t            1 : \"Landscape\",\n\t            2 : \"Portrait\",\n\t            3 : \"Night scene\"\n\t        },\n\t        SceneType : {\n\t            1 : \"Directly photographed\"\n\t        },\n\t        CustomRendered : {\n\t            0 : \"Normal process\",\n\t            1 : \"Custom process\"\n\t        },\n\t        WhiteBalance : {\n\t            0 : \"Auto white balance\",\n\t            1 : \"Manual white balance\"\n\t        },\n\t        GainControl : {\n\t            0 : \"None\",\n\t            1 : \"Low gain up\",\n\t            2 : \"High gain up\",\n\t            3 : \"Low gain down\",\n\t            4 : \"High gain down\"\n\t        },\n\t        Contrast : {\n\t            0 : \"Normal\",\n\t            1 : \"Soft\",\n\t            2 : \"Hard\"\n\t        },\n\t        Saturation : {\n\t            0 : \"Normal\",\n\t            1 : \"Low saturation\",\n\t            2 : \"High saturation\"\n\t        },\n\t        Sharpness : {\n\t            0 : \"Normal\",\n\t            1 : \"Soft\",\n\t            2 : \"Hard\"\n\t        },\n\t        SubjectDistanceRange : {\n\t            0 : \"Unknown\",\n\t            1 : \"Macro\",\n\t            2 : \"Close view\",\n\t            3 : \"Distant view\"\n\t        },\n\t        FileSource : {\n\t            3 : \"DSC\"\n\t        },\n\t\n\t        Components : {\n\t            0 : \"\",\n\t            1 : \"Y\",\n\t            2 : \"Cb\",\n\t            3 : \"Cr\",\n\t            4 : \"R\",\n\t            5 : \"G\",\n\t            6 : \"B\"\n\t        }\n\t    };\n\t\n\t    function addEvent(element, event, handler) {\n\t        if (element.addEventListener) {\n\t            element.addEventListener(event, handler, false);\n\t        } else if (element.attachEvent) {\n\t            element.attachEvent(\"on\" + event, handler);\n\t        }\n\t    }\n\t\n\t    function imageHasData(img) {\n\t        return !!(img.exifdata);\n\t    }\n\t\n\t\n\t    function base64ToArrayBuffer(base64, contentType) {\n\t        contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\n\t        base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\n\t        var binary = atob(base64);\n\t        var len = binary.length;\n\t        var buffer = new ArrayBuffer(len);\n\t        var view = new Uint8Array(buffer);\n\t        for (var i = 0; i < len; i++) {\n\t            view[i] = binary.charCodeAt(i);\n\t        }\n\t        return buffer;\n\t    }\n\t\n\t    function objectURLToBlob(url, callback) {\n\t        var http = new XMLHttpRequest();\n\t        http.open(\"GET\", url, true);\n\t        http.responseType = \"blob\";\n\t        http.onload = function(e) {\n\t            if (this.status == 200 || this.status === 0) {\n\t                callback(this.response);\n\t            }\n\t        };\n\t        http.send();\n\t    }\n\t\n\t    function getImageData(img, callback) {\n\t        function handleBinaryFile(binFile) {\n\t            var data = findEXIFinJPEG(binFile);\n\t            var iptcdata = findIPTCinJPEG(binFile);\n\t            img.exifdata = data || {};\n\t            img.iptcdata = iptcdata || {};\n\t            if (callback) {\n\t                callback.call(img);\n\t            }\n\t        }\n\t\n\t        if (img.src) {\n\t            if (/^data\\:/i.test(img.src)) { // Data URI\n\t                var arrayBuffer = base64ToArrayBuffer(img.src);\n\t                handleBinaryFile(arrayBuffer);\n\t\n\t            } else if (/^blob\\:/i.test(img.src)) { // Object URL\n\t                var fileReader = new FileReader();\n\t                fileReader.onload = function(e) {\n\t                    handleBinaryFile(e.target.result);\n\t                };\n\t                objectURLToBlob(img.src, function (blob) {\n\t                    fileReader.readAsArrayBuffer(blob);\n\t                });\n\t            } else {\n\t                var http = new XMLHttpRequest();\n\t                http.onload = function() {\n\t                    if (this.status == 200 || this.status === 0) {\n\t                        handleBinaryFile(http.response);\n\t                    } else {\n\t                        throw \"Could not load image\";\n\t                    }\n\t                    http = null;\n\t                };\n\t                http.open(\"GET\", img.src, true);\n\t                http.responseType = \"arraybuffer\";\n\t                http.send(null);\n\t            }\n\t        } else if (window.FileReader && (img instanceof window.Blob || img instanceof window.File)) {\n\t            var fileReader = new FileReader();\n\t            fileReader.onload = function(e) {\n\t                if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\n\t                handleBinaryFile(e.target.result);\n\t            };\n\t\n\t            fileReader.readAsArrayBuffer(img);\n\t        }\n\t    }\n\t\n\t    function findEXIFinJPEG(file) {\n\t        var dataView = new DataView(file);\n\t\n\t        if (debug) console.log(\"Got file of length \" + file.byteLength);\n\t        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n\t            if (debug) console.log(\"Not a valid JPEG\");\n\t            return false; // not a valid jpeg\n\t        }\n\t\n\t        var offset = 2,\n\t            length = file.byteLength,\n\t            marker;\n\t\n\t        while (offset < length) {\n\t            if (dataView.getUint8(offset) != 0xFF) {\n\t                if (debug) console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\n\t                return false; // not a valid marker, something is wrong\n\t            }\n\t\n\t            marker = dataView.getUint8(offset + 1);\n\t            if (debug) console.log(marker);\n\t\n\t            // we could implement handling for other markers here,\n\t            // but we're only looking for 0xFFE1 for EXIF data\n\t\n\t            if (marker == 225) {\n\t                if (debug) console.log(\"Found 0xFFE1 marker\");\n\t\n\t                return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);\n\t\n\t                // offset += 2 + file.getShortAt(offset+2, true);\n\t\n\t            } else {\n\t                offset += 2 + dataView.getUint16(offset+2);\n\t            }\n\t\n\t        }\n\t\n\t    }\n\t\n\t    function findIPTCinJPEG(file) {\n\t        var dataView = new DataView(file);\n\t\n\t        if (debug) console.log(\"Got file of length \" + file.byteLength);\n\t        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n\t            if (debug) console.log(\"Not a valid JPEG\");\n\t            return false; // not a valid jpeg\n\t        }\n\t\n\t        var offset = 2,\n\t            length = file.byteLength;\n\t\n\t\n\t        var isFieldSegmentStart = function(dataView, offset){\n\t            return (\n\t                dataView.getUint8(offset) === 0x38 &&\n\t                dataView.getUint8(offset+1) === 0x42 &&\n\t                dataView.getUint8(offset+2) === 0x49 &&\n\t                dataView.getUint8(offset+3) === 0x4D &&\n\t                dataView.getUint8(offset+4) === 0x04 &&\n\t                dataView.getUint8(offset+5) === 0x04\n\t            );\n\t        };\n\t\n\t        while (offset < length) {\n\t\n\t            if ( isFieldSegmentStart(dataView, offset )){\n\t\n\t                // Get the length of the name header (which is padded to an even number of bytes)\n\t                var nameHeaderLength = dataView.getUint8(offset+7);\n\t                if(nameHeaderLength % 2 !== 0) nameHeaderLength += 1;\n\t                // Check for pre photoshop 6 format\n\t                if(nameHeaderLength === 0) {\n\t                    // Always 4\n\t                    nameHeaderLength = 4;\n\t                }\n\t\n\t                var startOffset = offset + 8 + nameHeaderLength;\n\t                var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n\t\n\t                return readIPTCData(file, startOffset, sectionLength);\n\t\n\t                break;\n\t\n\t            }\n\t\n\t\n\t            // Not the marker, continue searching\n\t            offset++;\n\t\n\t        }\n\t\n\t    }\n\t    var IptcFieldMap = {\n\t        0x78 : 'caption',\n\t        0x6E : 'credit',\n\t        0x19 : 'keywords',\n\t        0x37 : 'dateCreated',\n\t        0x50 : 'byline',\n\t        0x55 : 'bylineTitle',\n\t        0x7A : 'captionWriter',\n\t        0x69 : 'headline',\n\t        0x74 : 'copyright',\n\t        0x0F : 'category'\n\t    };\n\t    function readIPTCData(file, startOffset, sectionLength){\n\t        var dataView = new DataView(file);\n\t        var data = {};\n\t        var fieldValue, fieldName, dataSize, segmentType, segmentSize;\n\t        var segmentStartPos = startOffset;\n\t        while(segmentStartPos < startOffset+sectionLength) {\n\t            if(dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos+1) === 0x02){\n\t                segmentType = dataView.getUint8(segmentStartPos+2);\n\t                if(segmentType in IptcFieldMap) {\n\t                    dataSize = dataView.getInt16(segmentStartPos+3);\n\t                    segmentSize = dataSize + 5;\n\t                    fieldName = IptcFieldMap[segmentType];\n\t                    fieldValue = getStringFromDB(dataView, segmentStartPos+5, dataSize);\n\t                    // Check if we already stored a value with this name\n\t                    if(data.hasOwnProperty(fieldName)) {\n\t                        // Value already stored with this name, create multivalue field\n\t                        if(data[fieldName] instanceof Array) {\n\t                            data[fieldName].push(fieldValue);\n\t                        }\n\t                        else {\n\t                            data[fieldName] = [data[fieldName], fieldValue];\n\t                        }\n\t                    }\n\t                    else {\n\t                        data[fieldName] = fieldValue;\n\t                    }\n\t                }\n\t\n\t            }\n\t            segmentStartPos++;\n\t        }\n\t        return data;\n\t    }\n\t\n\t\n\t\n\t    function readTags(file, tiffStart, dirStart, strings, bigEnd) {\n\t        var entries = file.getUint16(dirStart, !bigEnd),\n\t            tags = {},\n\t            entryOffset, tag,\n\t            i;\n\t\n\t        for (i=0;i<entries;i++) {\n\t            entryOffset = dirStart + i*12 + 2;\n\t            tag = strings[file.getUint16(entryOffset, !bigEnd)];\n\t            if (!tag && debug) console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\n\t            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\n\t        }\n\t        return tags;\n\t    }\n\t\n\t\n\t    function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\n\t        var type = file.getUint16(entryOffset+2, !bigEnd),\n\t            numValues = file.getUint32(entryOffset+4, !bigEnd),\n\t            valueOffset = file.getUint32(entryOffset+8, !bigEnd) + tiffStart,\n\t            offset,\n\t            vals, val, n,\n\t            numerator, denominator;\n\t\n\t        switch (type) {\n\t            case 1: // byte, 8-bit unsigned int\n\t            case 7: // undefined, 8-bit byte, value depending on field\n\t                if (numValues == 1) {\n\t                    return file.getUint8(entryOffset + 8, !bigEnd);\n\t                } else {\n\t                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);\n\t                    vals = [];\n\t                    for (n=0;n<numValues;n++) {\n\t                        vals[n] = file.getUint8(offset + n);\n\t                    }\n\t                    return vals;\n\t                }\n\t\n\t            case 2: // ascii, 8-bit byte\n\t                offset = numValues > 4 ? valueOffset : (entryOffset + 8);\n\t                return getStringFromDB(file, offset, numValues-1);\n\t\n\t            case 3: // short, 16 bit int\n\t                if (numValues == 1) {\n\t                    return file.getUint16(entryOffset + 8, !bigEnd);\n\t                } else {\n\t                    offset = numValues > 2 ? valueOffset : (entryOffset + 8);\n\t                    vals = [];\n\t                    for (n=0;n<numValues;n++) {\n\t                        vals[n] = file.getUint16(offset + 2*n, !bigEnd);\n\t                    }\n\t                    return vals;\n\t                }\n\t\n\t            case 4: // long, 32 bit int\n\t                if (numValues == 1) {\n\t                    return file.getUint32(entryOffset + 8, !bigEnd);\n\t                } else {\n\t                    vals = [];\n\t                    for (n=0;n<numValues;n++) {\n\t                        vals[n] = file.getUint32(valueOffset + 4*n, !bigEnd);\n\t                    }\n\t                    return vals;\n\t                }\n\t\n\t            case 5:    // rational = two long values, first is numerator, second is denominator\n\t                if (numValues == 1) {\n\t                    numerator = file.getUint32(valueOffset, !bigEnd);\n\t                    denominator = file.getUint32(valueOffset+4, !bigEnd);\n\t                    val = new Number(numerator / denominator);\n\t                    val.numerator = numerator;\n\t                    val.denominator = denominator;\n\t                    return val;\n\t                } else {\n\t                    vals = [];\n\t                    for (n=0;n<numValues;n++) {\n\t                        numerator = file.getUint32(valueOffset + 8*n, !bigEnd);\n\t                        denominator = file.getUint32(valueOffset+4 + 8*n, !bigEnd);\n\t                        vals[n] = new Number(numerator / denominator);\n\t                        vals[n].numerator = numerator;\n\t                        vals[n].denominator = denominator;\n\t                    }\n\t                    return vals;\n\t                }\n\t\n\t            case 9: // slong, 32 bit signed int\n\t                if (numValues == 1) {\n\t                    return file.getInt32(entryOffset + 8, !bigEnd);\n\t                } else {\n\t                    vals = [];\n\t                    for (n=0;n<numValues;n++) {\n\t                        vals[n] = file.getInt32(valueOffset + 4*n, !bigEnd);\n\t                    }\n\t                    return vals;\n\t                }\n\t\n\t            case 10: // signed rational, two slongs, first is numerator, second is denominator\n\t                if (numValues == 1) {\n\t                    return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset+4, !bigEnd);\n\t                } else {\n\t                    vals = [];\n\t                    for (n=0;n<numValues;n++) {\n\t                        vals[n] = file.getInt32(valueOffset + 8*n, !bigEnd) / file.getInt32(valueOffset+4 + 8*n, !bigEnd);\n\t                    }\n\t                    return vals;\n\t                }\n\t        }\n\t    }\n\t\n\t    function getStringFromDB(buffer, start, length) {\n\t        var outstr = \"\";\n\t        for (n = start; n < start+length; n++) {\n\t            outstr += String.fromCharCode(buffer.getUint8(n));\n\t        }\n\t        return outstr;\n\t    }\n\t\n\t    function readEXIFData(file, start) {\n\t        if (getStringFromDB(file, start, 4) != \"Exif\") {\n\t            if (debug) console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\n\t            return false;\n\t        }\n\t\n\t        var bigEnd,\n\t            tags, tag,\n\t            exifData, gpsData,\n\t            tiffOffset = start + 6;\n\t\n\t        // test for TIFF validity and endianness\n\t        if (file.getUint16(tiffOffset) == 0x4949) {\n\t            bigEnd = false;\n\t        } else if (file.getUint16(tiffOffset) == 0x4D4D) {\n\t            bigEnd = true;\n\t        } else {\n\t            if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\n\t            return false;\n\t        }\n\t\n\t        if (file.getUint16(tiffOffset+2, !bigEnd) != 0x002A) {\n\t            if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\n\t            return false;\n\t        }\n\t\n\t        var firstIFDOffset = file.getUint32(tiffOffset+4, !bigEnd);\n\t\n\t        if (firstIFDOffset < 0x00000008) {\n\t            if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset+4, !bigEnd));\n\t            return false;\n\t        }\n\t\n\t        tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\n\t\n\t        if (tags.ExifIFDPointer) {\n\t            exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\n\t            for (tag in exifData) {\n\t                switch (tag) {\n\t                    case \"LightSource\" :\n\t                    case \"Flash\" :\n\t                    case \"MeteringMode\" :\n\t                    case \"ExposureProgram\" :\n\t                    case \"SensingMethod\" :\n\t                    case \"SceneCaptureType\" :\n\t                    case \"SceneType\" :\n\t                    case \"CustomRendered\" :\n\t                    case \"WhiteBalance\" :\n\t                    case \"GainControl\" :\n\t                    case \"Contrast\" :\n\t                    case \"Saturation\" :\n\t                    case \"Sharpness\" :\n\t                    case \"SubjectDistanceRange\" :\n\t                    case \"FileSource\" :\n\t                        exifData[tag] = StringValues[tag][exifData[tag]];\n\t                        break;\n\t\n\t                    case \"ExifVersion\" :\n\t                    case \"FlashpixVersion\" :\n\t                        exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\n\t                        break;\n\t\n\t                    case \"ComponentsConfiguration\" :\n\t                        exifData[tag] =\n\t                            StringValues.Components[exifData[tag][0]] +\n\t                            StringValues.Components[exifData[tag][1]] +\n\t                            StringValues.Components[exifData[tag][2]] +\n\t                            StringValues.Components[exifData[tag][3]];\n\t                        break;\n\t                }\n\t                tags[tag] = exifData[tag];\n\t            }\n\t        }\n\t\n\t        if (tags.GPSInfoIFDPointer) {\n\t            gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\n\t            for (tag in gpsData) {\n\t                switch (tag) {\n\t                    case \"GPSVersionID\" :\n\t                        gpsData[tag] = gpsData[tag][0] +\n\t                            \".\" + gpsData[tag][1] +\n\t                            \".\" + gpsData[tag][2] +\n\t                            \".\" + gpsData[tag][3];\n\t                        break;\n\t                }\n\t                tags[tag] = gpsData[tag];\n\t            }\n\t        }\n\t\n\t        return tags;\n\t    }\n\t\n\t    EXIF.getData = function(img, callback) {\n\t        if ((img instanceof Image || img instanceof HTMLImageElement) && !img.complete) return false;\n\t\n\t        if (!imageHasData(img)) {\n\t            getImageData(img, callback);\n\t        } else {\n\t            if (callback) {\n\t                callback.call(img);\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    EXIF.getTag = function(img, tag) {\n\t        if (!imageHasData(img)) return;\n\t        return img.exifdata[tag];\n\t    }\n\t\n\t    EXIF.getAllTags = function(img) {\n\t        if (!imageHasData(img)) return {};\n\t        var a,\n\t            data = img.exifdata,\n\t            tags = {};\n\t        for (a in data) {\n\t            if (data.hasOwnProperty(a)) {\n\t                tags[a] = data[a];\n\t            }\n\t        }\n\t        return tags;\n\t    }\n\t\n\t    EXIF.pretty = function(img) {\n\t        if (!imageHasData(img)) return \"\";\n\t        var a,\n\t            data = img.exifdata,\n\t            strPretty = \"\";\n\t        for (a in data) {\n\t            if (data.hasOwnProperty(a)) {\n\t                if (typeof data[a] == \"object\") {\n\t                    if (data[a] instanceof Number) {\n\t                        strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\n\t                    } else {\n\t                        strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\n\t                    }\n\t                } else {\n\t                    strPretty += a + \" : \" + data[a] + \"\\r\\n\";\n\t                }\n\t            }\n\t        }\n\t        return strPretty;\n\t    }\n\t\n\t    EXIF.readFromBinaryFile = function(file) {\n\t        return findEXIFinJPEG(file);\n\t    }\n\t\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t            return EXIF;\n\t        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t}.call(this));\n\t\n\n\n/***/ }\n\n});\n\n\n// WEBPACK FOOTER //\n// 3.3.js?v=fb5f58f6093cfaae2ffa","(function() {\n\n    var debug = false;\n\n    var root = this;\n\n    var EXIF = function(obj) {\n        if (obj instanceof EXIF) return obj;\n        if (!(this instanceof EXIF)) return new EXIF(obj);\n        this.EXIFwrapped = obj;\n    };\n\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = EXIF;\n        }\n        exports.EXIF = EXIF;\n    } else {\n        root.EXIF = EXIF;\n    }\n\n    var ExifTags = EXIF.Tags = {\n\n        // version tags\n        0x9000 : \"ExifVersion\",             // EXIF version\n        0xA000 : \"FlashpixVersion\",         // Flashpix format version\n\n        // colorspace tags\n        0xA001 : \"ColorSpace\",              // Color space information tag\n\n        // image configuration\n        0xA002 : \"PixelXDimension\",         // Valid width of meaningful image\n        0xA003 : \"PixelYDimension\",         // Valid height of meaningful image\n        0x9101 : \"ComponentsConfiguration\", // Information about channels\n        0x9102 : \"CompressedBitsPerPixel\",  // Compressed bits per pixel\n\n        // user information\n        0x927C : \"MakerNote\",               // Any desired information written by the manufacturer\n        0x9286 : \"UserComment\",             // Comments by user\n\n        // related file\n        0xA004 : \"RelatedSoundFile\",        // Name of related sound file\n\n        // date and time\n        0x9003 : \"DateTimeOriginal\",        // Date and time when the original image was generated\n        0x9004 : \"DateTimeDigitized\",       // Date and time when the image was stored digitally\n        0x9290 : \"SubsecTime\",              // Fractions of seconds for DateTime\n        0x9291 : \"SubsecTimeOriginal\",      // Fractions of seconds for DateTimeOriginal\n        0x9292 : \"SubsecTimeDigitized\",     // Fractions of seconds for DateTimeDigitized\n\n        // picture-taking conditions\n        0x829A : \"ExposureTime\",            // Exposure time (in seconds)\n        0x829D : \"FNumber\",                 // F number\n        0x8822 : \"ExposureProgram\",         // Exposure program\n        0x8824 : \"SpectralSensitivity\",     // Spectral sensitivity\n        0x8827 : \"ISOSpeedRatings\",         // ISO speed rating\n        0x8828 : \"OECF\",                    // Optoelectric conversion factor\n        0x9201 : \"ShutterSpeedValue\",       // Shutter speed\n        0x9202 : \"ApertureValue\",           // Lens aperture\n        0x9203 : \"BrightnessValue\",         // Value of brightness\n        0x9204 : \"ExposureBias\",            // Exposure bias\n        0x9205 : \"MaxApertureValue\",        // Smallest F number of lens\n        0x9206 : \"SubjectDistance\",         // Distance to subject in meters\n        0x9207 : \"MeteringMode\",            // Metering mode\n        0x9208 : \"LightSource\",             // Kind of light source\n        0x9209 : \"Flash\",                   // Flash status\n        0x9214 : \"SubjectArea\",             // Location and area of main subject\n        0x920A : \"FocalLength\",             // Focal length of the lens in mm\n        0xA20B : \"FlashEnergy\",             // Strobe energy in BCPS\n        0xA20C : \"SpatialFrequencyResponse\",    //\n        0xA20E : \"FocalPlaneXResolution\",   // Number of pixels in width direction per FocalPlaneResolutionUnit\n        0xA20F : \"FocalPlaneYResolution\",   // Number of pixels in height direction per FocalPlaneResolutionUnit\n        0xA210 : \"FocalPlaneResolutionUnit\",    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\n        0xA214 : \"SubjectLocation\",         // Location of subject in image\n        0xA215 : \"ExposureIndex\",           // Exposure index selected on camera\n        0xA217 : \"SensingMethod\",           // Image sensor type\n        0xA300 : \"FileSource\",              // Image source (3 == DSC)\n        0xA301 : \"SceneType\",               // Scene type (1 == directly photographed)\n        0xA302 : \"CFAPattern\",              // Color filter array geometric pattern\n        0xA401 : \"CustomRendered\",          // Special processing\n        0xA402 : \"ExposureMode\",            // Exposure mode\n        0xA403 : \"WhiteBalance\",            // 1 = auto white balance, 2 = manual\n        0xA404 : \"DigitalZoomRation\",       // Digital zoom ratio\n        0xA405 : \"FocalLengthIn35mmFilm\",   // Equivalent foacl length assuming 35mm film camera (in mm)\n        0xA406 : \"SceneCaptureType\",        // Type of scene\n        0xA407 : \"GainControl\",             // Degree of overall image gain adjustment\n        0xA408 : \"Contrast\",                // Direction of contrast processing applied by camera\n        0xA409 : \"Saturation\",              // Direction of saturation processing applied by camera\n        0xA40A : \"Sharpness\",               // Direction of sharpness processing applied by camera\n        0xA40B : \"DeviceSettingDescription\",    //\n        0xA40C : \"SubjectDistanceRange\",    // Distance to subject\n\n        // other tags\n        0xA005 : \"InteroperabilityIFDPointer\",\n        0xA420 : \"ImageUniqueID\"            // Identifier assigned uniquely to each image\n    };\n\n    var TiffTags = EXIF.TiffTags = {\n        0x0100 : \"ImageWidth\",\n        0x0101 : \"ImageHeight\",\n        0x8769 : \"ExifIFDPointer\",\n        0x8825 : \"GPSInfoIFDPointer\",\n        0xA005 : \"InteroperabilityIFDPointer\",\n        0x0102 : \"BitsPerSample\",\n        0x0103 : \"Compression\",\n        0x0106 : \"PhotometricInterpretation\",\n        0x0112 : \"Orientation\",\n        0x0115 : \"SamplesPerPixel\",\n        0x011C : \"PlanarConfiguration\",\n        0x0212 : \"YCbCrSubSampling\",\n        0x0213 : \"YCbCrPositioning\",\n        0x011A : \"XResolution\",\n        0x011B : \"YResolution\",\n        0x0128 : \"ResolutionUnit\",\n        0x0111 : \"StripOffsets\",\n        0x0116 : \"RowsPerStrip\",\n        0x0117 : \"StripByteCounts\",\n        0x0201 : \"JPEGInterchangeFormat\",\n        0x0202 : \"JPEGInterchangeFormatLength\",\n        0x012D : \"TransferFunction\",\n        0x013E : \"WhitePoint\",\n        0x013F : \"PrimaryChromaticities\",\n        0x0211 : \"YCbCrCoefficients\",\n        0x0214 : \"ReferenceBlackWhite\",\n        0x0132 : \"DateTime\",\n        0x010E : \"ImageDescription\",\n        0x010F : \"Make\",\n        0x0110 : \"Model\",\n        0x0131 : \"Software\",\n        0x013B : \"Artist\",\n        0x8298 : \"Copyright\"\n    };\n\n    var GPSTags = EXIF.GPSTags = {\n        0x0000 : \"GPSVersionID\",\n        0x0001 : \"GPSLatitudeRef\",\n        0x0002 : \"GPSLatitude\",\n        0x0003 : \"GPSLongitudeRef\",\n        0x0004 : \"GPSLongitude\",\n        0x0005 : \"GPSAltitudeRef\",\n        0x0006 : \"GPSAltitude\",\n        0x0007 : \"GPSTimeStamp\",\n        0x0008 : \"GPSSatellites\",\n        0x0009 : \"GPSStatus\",\n        0x000A : \"GPSMeasureMode\",\n        0x000B : \"GPSDOP\",\n        0x000C : \"GPSSpeedRef\",\n        0x000D : \"GPSSpeed\",\n        0x000E : \"GPSTrackRef\",\n        0x000F : \"GPSTrack\",\n        0x0010 : \"GPSImgDirectionRef\",\n        0x0011 : \"GPSImgDirection\",\n        0x0012 : \"GPSMapDatum\",\n        0x0013 : \"GPSDestLatitudeRef\",\n        0x0014 : \"GPSDestLatitude\",\n        0x0015 : \"GPSDestLongitudeRef\",\n        0x0016 : \"GPSDestLongitude\",\n        0x0017 : \"GPSDestBearingRef\",\n        0x0018 : \"GPSDestBearing\",\n        0x0019 : \"GPSDestDistanceRef\",\n        0x001A : \"GPSDestDistance\",\n        0x001B : \"GPSProcessingMethod\",\n        0x001C : \"GPSAreaInformation\",\n        0x001D : \"GPSDateStamp\",\n        0x001E : \"GPSDifferential\"\n    };\n\n    var StringValues = EXIF.StringValues = {\n        ExposureProgram : {\n            0 : \"Not defined\",\n            1 : \"Manual\",\n            2 : \"Normal program\",\n            3 : \"Aperture priority\",\n            4 : \"Shutter priority\",\n            5 : \"Creative program\",\n            6 : \"Action program\",\n            7 : \"Portrait mode\",\n            8 : \"Landscape mode\"\n        },\n        MeteringMode : {\n            0 : \"Unknown\",\n            1 : \"Average\",\n            2 : \"CenterWeightedAverage\",\n            3 : \"Spot\",\n            4 : \"MultiSpot\",\n            5 : \"Pattern\",\n            6 : \"Partial\",\n            255 : \"Other\"\n        },\n        LightSource : {\n            0 : \"Unknown\",\n            1 : \"Daylight\",\n            2 : \"Fluorescent\",\n            3 : \"Tungsten (incandescent light)\",\n            4 : \"Flash\",\n            9 : \"Fine weather\",\n            10 : \"Cloudy weather\",\n            11 : \"Shade\",\n            12 : \"Daylight fluorescent (D 5700 - 7100K)\",\n            13 : \"Day white fluorescent (N 4600 - 5400K)\",\n            14 : \"Cool white fluorescent (W 3900 - 4500K)\",\n            15 : \"White fluorescent (WW 3200 - 3700K)\",\n            17 : \"Standard light A\",\n            18 : \"Standard light B\",\n            19 : \"Standard light C\",\n            20 : \"D55\",\n            21 : \"D65\",\n            22 : \"D75\",\n            23 : \"D50\",\n            24 : \"ISO studio tungsten\",\n            255 : \"Other\"\n        },\n        Flash : {\n            0x0000 : \"Flash did not fire\",\n            0x0001 : \"Flash fired\",\n            0x0005 : \"Strobe return light not detected\",\n            0x0007 : \"Strobe return light detected\",\n            0x0009 : \"Flash fired, compulsory flash mode\",\n            0x000D : \"Flash fired, compulsory flash mode, return light not detected\",\n            0x000F : \"Flash fired, compulsory flash mode, return light detected\",\n            0x0010 : \"Flash did not fire, compulsory flash mode\",\n            0x0018 : \"Flash did not fire, auto mode\",\n            0x0019 : \"Flash fired, auto mode\",\n            0x001D : \"Flash fired, auto mode, return light not detected\",\n            0x001F : \"Flash fired, auto mode, return light detected\",\n            0x0020 : \"No flash function\",\n            0x0041 : \"Flash fired, red-eye reduction mode\",\n            0x0045 : \"Flash fired, red-eye reduction mode, return light not detected\",\n            0x0047 : \"Flash fired, red-eye reduction mode, return light detected\",\n            0x0049 : \"Flash fired, compulsory flash mode, red-eye reduction mode\",\n            0x004D : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\n            0x004F : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\n            0x0059 : \"Flash fired, auto mode, red-eye reduction mode\",\n            0x005D : \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\n            0x005F : \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\n        },\n        SensingMethod : {\n            1 : \"Not defined\",\n            2 : \"One-chip color area sensor\",\n            3 : \"Two-chip color area sensor\",\n            4 : \"Three-chip color area sensor\",\n            5 : \"Color sequential area sensor\",\n            7 : \"Trilinear sensor\",\n            8 : \"Color sequential linear sensor\"\n        },\n        SceneCaptureType : {\n            0 : \"Standard\",\n            1 : \"Landscape\",\n            2 : \"Portrait\",\n            3 : \"Night scene\"\n        },\n        SceneType : {\n            1 : \"Directly photographed\"\n        },\n        CustomRendered : {\n            0 : \"Normal process\",\n            1 : \"Custom process\"\n        },\n        WhiteBalance : {\n            0 : \"Auto white balance\",\n            1 : \"Manual white balance\"\n        },\n        GainControl : {\n            0 : \"None\",\n            1 : \"Low gain up\",\n            2 : \"High gain up\",\n            3 : \"Low gain down\",\n            4 : \"High gain down\"\n        },\n        Contrast : {\n            0 : \"Normal\",\n            1 : \"Soft\",\n            2 : \"Hard\"\n        },\n        Saturation : {\n            0 : \"Normal\",\n            1 : \"Low saturation\",\n            2 : \"High saturation\"\n        },\n        Sharpness : {\n            0 : \"Normal\",\n            1 : \"Soft\",\n            2 : \"Hard\"\n        },\n        SubjectDistanceRange : {\n            0 : \"Unknown\",\n            1 : \"Macro\",\n            2 : \"Close view\",\n            3 : \"Distant view\"\n        },\n        FileSource : {\n            3 : \"DSC\"\n        },\n\n        Components : {\n            0 : \"\",\n            1 : \"Y\",\n            2 : \"Cb\",\n            3 : \"Cr\",\n            4 : \"R\",\n            5 : \"G\",\n            6 : \"B\"\n        }\n    };\n\n    function addEvent(element, event, handler) {\n        if (element.addEventListener) {\n            element.addEventListener(event, handler, false);\n        } else if (element.attachEvent) {\n            element.attachEvent(\"on\" + event, handler);\n        }\n    }\n\n    function imageHasData(img) {\n        return !!(img.exifdata);\n    }\n\n\n    function base64ToArrayBuffer(base64, contentType) {\n        contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\n        base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\n        var binary = atob(base64);\n        var len = binary.length;\n        var buffer = new ArrayBuffer(len);\n        var view = new Uint8Array(buffer);\n        for (var i = 0; i < len; i++) {\n            view[i] = binary.charCodeAt(i);\n        }\n        return buffer;\n    }\n\n    function objectURLToBlob(url, callback) {\n        var http = new XMLHttpRequest();\n        http.open(\"GET\", url, true);\n        http.responseType = \"blob\";\n        http.onload = function(e) {\n            if (this.status == 200 || this.status === 0) {\n                callback(this.response);\n            }\n        };\n        http.send();\n    }\n\n    function getImageData(img, callback) {\n        function handleBinaryFile(binFile) {\n            var data = findEXIFinJPEG(binFile);\n            var iptcdata = findIPTCinJPEG(binFile);\n            img.exifdata = data || {};\n            img.iptcdata = iptcdata || {};\n            if (callback) {\n                callback.call(img);\n            }\n        }\n\n        if (img.src) {\n            if (/^data\\:/i.test(img.src)) { // Data URI\n                var arrayBuffer = base64ToArrayBuffer(img.src);\n                handleBinaryFile(arrayBuffer);\n\n            } else if (/^blob\\:/i.test(img.src)) { // Object URL\n                var fileReader = new FileReader();\n                fileReader.onload = function(e) {\n                    handleBinaryFile(e.target.result);\n                };\n                objectURLToBlob(img.src, function (blob) {\n                    fileReader.readAsArrayBuffer(blob);\n                });\n            } else {\n                var http = new XMLHttpRequest();\n                http.onload = function() {\n                    if (this.status == 200 || this.status === 0) {\n                        handleBinaryFile(http.response);\n                    } else {\n                        throw \"Could not load image\";\n                    }\n                    http = null;\n                };\n                http.open(\"GET\", img.src, true);\n                http.responseType = \"arraybuffer\";\n                http.send(null);\n            }\n        } else if (window.FileReader && (img instanceof window.Blob || img instanceof window.File)) {\n            var fileReader = new FileReader();\n            fileReader.onload = function(e) {\n                if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\n                handleBinaryFile(e.target.result);\n            };\n\n            fileReader.readAsArrayBuffer(img);\n        }\n    }\n\n    function findEXIFinJPEG(file) {\n        var dataView = new DataView(file);\n\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n            if (debug) console.log(\"Not a valid JPEG\");\n            return false; // not a valid jpeg\n        }\n\n        var offset = 2,\n            length = file.byteLength,\n            marker;\n\n        while (offset < length) {\n            if (dataView.getUint8(offset) != 0xFF) {\n                if (debug) console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\n                return false; // not a valid marker, something is wrong\n            }\n\n            marker = dataView.getUint8(offset + 1);\n            if (debug) console.log(marker);\n\n            // we could implement handling for other markers here,\n            // but we're only looking for 0xFFE1 for EXIF data\n\n            if (marker == 225) {\n                if (debug) console.log(\"Found 0xFFE1 marker\");\n\n                return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);\n\n                // offset += 2 + file.getShortAt(offset+2, true);\n\n            } else {\n                offset += 2 + dataView.getUint16(offset+2);\n            }\n\n        }\n\n    }\n\n    function findIPTCinJPEG(file) {\n        var dataView = new DataView(file);\n\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n            if (debug) console.log(\"Not a valid JPEG\");\n            return false; // not a valid jpeg\n        }\n\n        var offset = 2,\n            length = file.byteLength;\n\n\n        var isFieldSegmentStart = function(dataView, offset){\n            return (\n                dataView.getUint8(offset) === 0x38 &&\n                dataView.getUint8(offset+1) === 0x42 &&\n                dataView.getUint8(offset+2) === 0x49 &&\n                dataView.getUint8(offset+3) === 0x4D &&\n                dataView.getUint8(offset+4) === 0x04 &&\n                dataView.getUint8(offset+5) === 0x04\n            );\n        };\n\n        while (offset < length) {\n\n            if ( isFieldSegmentStart(dataView, offset )){\n\n                // Get the length of the name header (which is padded to an even number of bytes)\n                var nameHeaderLength = dataView.getUint8(offset+7);\n                if(nameHeaderLength % 2 !== 0) nameHeaderLength += 1;\n                // Check for pre photoshop 6 format\n                if(nameHeaderLength === 0) {\n                    // Always 4\n                    nameHeaderLength = 4;\n                }\n\n                var startOffset = offset + 8 + nameHeaderLength;\n                var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n\n                return readIPTCData(file, startOffset, sectionLength);\n\n                break;\n\n            }\n\n\n            // Not the marker, continue searching\n            offset++;\n\n        }\n\n    }\n    var IptcFieldMap = {\n        0x78 : 'caption',\n        0x6E : 'credit',\n        0x19 : 'keywords',\n        0x37 : 'dateCreated',\n        0x50 : 'byline',\n        0x55 : 'bylineTitle',\n        0x7A : 'captionWriter',\n        0x69 : 'headline',\n        0x74 : 'copyright',\n        0x0F : 'category'\n    };\n    function readIPTCData(file, startOffset, sectionLength){\n        var dataView = new DataView(file);\n        var data = {};\n        var fieldValue, fieldName, dataSize, segmentType, segmentSize;\n        var segmentStartPos = startOffset;\n        while(segmentStartPos < startOffset+sectionLength) {\n            if(dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos+1) === 0x02){\n                segmentType = dataView.getUint8(segmentStartPos+2);\n                if(segmentType in IptcFieldMap) {\n                    dataSize = dataView.getInt16(segmentStartPos+3);\n                    segmentSize = dataSize + 5;\n                    fieldName = IptcFieldMap[segmentType];\n                    fieldValue = getStringFromDB(dataView, segmentStartPos+5, dataSize);\n                    // Check if we already stored a value with this name\n                    if(data.hasOwnProperty(fieldName)) {\n                        // Value already stored with this name, create multivalue field\n                        if(data[fieldName] instanceof Array) {\n                            data[fieldName].push(fieldValue);\n                        }\n                        else {\n                            data[fieldName] = [data[fieldName], fieldValue];\n                        }\n                    }\n                    else {\n                        data[fieldName] = fieldValue;\n                    }\n                }\n\n            }\n            segmentStartPos++;\n        }\n        return data;\n    }\n\n\n\n    function readTags(file, tiffStart, dirStart, strings, bigEnd) {\n        var entries = file.getUint16(dirStart, !bigEnd),\n            tags = {},\n            entryOffset, tag,\n            i;\n\n        for (i=0;i<entries;i++) {\n            entryOffset = dirStart + i*12 + 2;\n            tag = strings[file.getUint16(entryOffset, !bigEnd)];\n            if (!tag && debug) console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\n            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\n        }\n        return tags;\n    }\n\n\n    function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\n        var type = file.getUint16(entryOffset+2, !bigEnd),\n            numValues = file.getUint32(entryOffset+4, !bigEnd),\n            valueOffset = file.getUint32(entryOffset+8, !bigEnd) + tiffStart,\n            offset,\n            vals, val, n,\n            numerator, denominator;\n\n        switch (type) {\n            case 1: // byte, 8-bit unsigned int\n            case 7: // undefined, 8-bit byte, value depending on field\n                if (numValues == 1) {\n                    return file.getUint8(entryOffset + 8, !bigEnd);\n                } else {\n                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getUint8(offset + n);\n                    }\n                    return vals;\n                }\n\n            case 2: // ascii, 8-bit byte\n                offset = numValues > 4 ? valueOffset : (entryOffset + 8);\n                return getStringFromDB(file, offset, numValues-1);\n\n            case 3: // short, 16 bit int\n                if (numValues == 1) {\n                    return file.getUint16(entryOffset + 8, !bigEnd);\n                } else {\n                    offset = numValues > 2 ? valueOffset : (entryOffset + 8);\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getUint16(offset + 2*n, !bigEnd);\n                    }\n                    return vals;\n                }\n\n            case 4: // long, 32 bit int\n                if (numValues == 1) {\n                    return file.getUint32(entryOffset + 8, !bigEnd);\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getUint32(valueOffset + 4*n, !bigEnd);\n                    }\n                    return vals;\n                }\n\n            case 5:    // rational = two long values, first is numerator, second is denominator\n                if (numValues == 1) {\n                    numerator = file.getUint32(valueOffset, !bigEnd);\n                    denominator = file.getUint32(valueOffset+4, !bigEnd);\n                    val = new Number(numerator / denominator);\n                    val.numerator = numerator;\n                    val.denominator = denominator;\n                    return val;\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        numerator = file.getUint32(valueOffset + 8*n, !bigEnd);\n                        denominator = file.getUint32(valueOffset+4 + 8*n, !bigEnd);\n                        vals[n] = new Number(numerator / denominator);\n                        vals[n].numerator = numerator;\n                        vals[n].denominator = denominator;\n                    }\n                    return vals;\n                }\n\n            case 9: // slong, 32 bit signed int\n                if (numValues == 1) {\n                    return file.getInt32(entryOffset + 8, !bigEnd);\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getInt32(valueOffset + 4*n, !bigEnd);\n                    }\n                    return vals;\n                }\n\n            case 10: // signed rational, two slongs, first is numerator, second is denominator\n                if (numValues == 1) {\n                    return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset+4, !bigEnd);\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getInt32(valueOffset + 8*n, !bigEnd) / file.getInt32(valueOffset+4 + 8*n, !bigEnd);\n                    }\n                    return vals;\n                }\n        }\n    }\n\n    function getStringFromDB(buffer, start, length) {\n        var outstr = \"\";\n        for (n = start; n < start+length; n++) {\n            outstr += String.fromCharCode(buffer.getUint8(n));\n        }\n        return outstr;\n    }\n\n    function readEXIFData(file, start) {\n        if (getStringFromDB(file, start, 4) != \"Exif\") {\n            if (debug) console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\n            return false;\n        }\n\n        var bigEnd,\n            tags, tag,\n            exifData, gpsData,\n            tiffOffset = start + 6;\n\n        // test for TIFF validity and endianness\n        if (file.getUint16(tiffOffset) == 0x4949) {\n            bigEnd = false;\n        } else if (file.getUint16(tiffOffset) == 0x4D4D) {\n            bigEnd = true;\n        } else {\n            if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\n            return false;\n        }\n\n        if (file.getUint16(tiffOffset+2, !bigEnd) != 0x002A) {\n            if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\n            return false;\n        }\n\n        var firstIFDOffset = file.getUint32(tiffOffset+4, !bigEnd);\n\n        if (firstIFDOffset < 0x00000008) {\n            if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset+4, !bigEnd));\n            return false;\n        }\n\n        tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\n\n        if (tags.ExifIFDPointer) {\n            exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\n            for (tag in exifData) {\n                switch (tag) {\n                    case \"LightSource\" :\n                    case \"Flash\" :\n                    case \"MeteringMode\" :\n                    case \"ExposureProgram\" :\n                    case \"SensingMethod\" :\n                    case \"SceneCaptureType\" :\n                    case \"SceneType\" :\n                    case \"CustomRendered\" :\n                    case \"WhiteBalance\" :\n                    case \"GainControl\" :\n                    case \"Contrast\" :\n                    case \"Saturation\" :\n                    case \"Sharpness\" :\n                    case \"SubjectDistanceRange\" :\n                    case \"FileSource\" :\n                        exifData[tag] = StringValues[tag][exifData[tag]];\n                        break;\n\n                    case \"ExifVersion\" :\n                    case \"FlashpixVersion\" :\n                        exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\n                        break;\n\n                    case \"ComponentsConfiguration\" :\n                        exifData[tag] =\n                            StringValues.Components[exifData[tag][0]] +\n                            StringValues.Components[exifData[tag][1]] +\n                            StringValues.Components[exifData[tag][2]] +\n                            StringValues.Components[exifData[tag][3]];\n                        break;\n                }\n                tags[tag] = exifData[tag];\n            }\n        }\n\n        if (tags.GPSInfoIFDPointer) {\n            gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\n            for (tag in gpsData) {\n                switch (tag) {\n                    case \"GPSVersionID\" :\n                        gpsData[tag] = gpsData[tag][0] +\n                            \".\" + gpsData[tag][1] +\n                            \".\" + gpsData[tag][2] +\n                            \".\" + gpsData[tag][3];\n                        break;\n                }\n                tags[tag] = gpsData[tag];\n            }\n        }\n\n        return tags;\n    }\n\n    EXIF.getData = function(img, callback) {\n        if ((img instanceof Image || img instanceof HTMLImageElement) && !img.complete) return false;\n\n        if (!imageHasData(img)) {\n            getImageData(img, callback);\n        } else {\n            if (callback) {\n                callback.call(img);\n            }\n        }\n        return true;\n    }\n\n    EXIF.getTag = function(img, tag) {\n        if (!imageHasData(img)) return;\n        return img.exifdata[tag];\n    }\n\n    EXIF.getAllTags = function(img) {\n        if (!imageHasData(img)) return {};\n        var a,\n            data = img.exifdata,\n            tags = {};\n        for (a in data) {\n            if (data.hasOwnProperty(a)) {\n                tags[a] = data[a];\n            }\n        }\n        return tags;\n    }\n\n    EXIF.pretty = function(img) {\n        if (!imageHasData(img)) return \"\";\n        var a,\n            data = img.exifdata,\n            strPretty = \"\";\n        for (a in data) {\n            if (data.hasOwnProperty(a)) {\n                if (typeof data[a] == \"object\") {\n                    if (data[a] instanceof Number) {\n                        strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\n                    } else {\n                        strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\n                    }\n                } else {\n                    strPretty += a + \" : \" + data[a] + \"\\r\\n\";\n                }\n            }\n        }\n        return strPretty;\n    }\n\n    EXIF.readFromBinaryFile = function(file) {\n        return findEXIFinJPEG(file);\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        define([], function() {\n            return EXIF;\n        });\n    }\n}.call(this));\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.0.1.3@html5-image-compress/src/libs/exif.js\n// module id = 697\n// module chunks = 3"],"sourceRoot":""}