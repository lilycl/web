{"version":3,"sources":["webpack:///1.1.js","webpack:///./~/.0.1.3@html5-image-compress/src/libs/megapix-image.js"],"names":["webpackJsonp","695","module","exports","__webpack_require__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","detectSubsampling","img","iw","naturalWidth","ih","naturalHeight","canvas","document","createElement","width","height","ctx","getContext","drawImage","getImageData","data","detectVerticalSquash","sy","ey","py","alpha","ratio","renderImageToDataURL","options","doSquash","renderImageToCanvas","toDataURL","quality","save","transformCoordinate","orientation","subsampled","d","tmpCanvas","tmpCtx","vertSquashRatio","dw","Math","ceil","dh","dy","sx","dx","clearRect","restore","translate","scale","rotate","PI","MegaPixImage","srcImage","window","Blob","URL","Error","Image","src","createObjectURL","this","blob","_this","onload","onerror","listeners","imageLoadListeners","i","len","length","webkitURL","prototype","render","target","callback","push","imgWidth","imgHeight","maxWidth","maxHeight","type","opt","k","tagName","toLowerCase","onrender","revokeObjectURL","apply","undefined"],"mappings":"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","file":"1.1.js?v=fb5f58f6093cfaae2ffa","sourcesContent":["webpackJsonp([1],{\n\n/***/ 695:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n\t * Mega pixel image rendering library for iOS6 Safari\n\t *\n\t * Fixes iOS6 Safari's image file rendering issue for large size image (over mega-pixel),\n\t * which causes unexpected subsampling when drawing it in canvas.\n\t * By using this library, you can safely render the image with proper stretching.\n\t *\n\t * Copyright (c) 2012 Shinichi Tomita <shinichi.tomita@gmail.com>\n\t * Released under the MIT license\n\t */\n\t(function() {\n\t\n\t  /**\n\t   * Detect subsampling in loaded image.\n\t   * In iOS, larger images than 2M pixels may be subsampled in rendering.\n\t   */\n\t  function detectSubsampling(img) {\n\t    var iw = img.naturalWidth, ih = img.naturalHeight;\n\t    if (iw * ih > 1024 * 1024) { // subsampling may happen over megapixel image\n\t      var canvas = document.createElement('canvas');\n\t      canvas.width = canvas.height = 1;\n\t      var ctx = canvas.getContext('2d');\n\t      ctx.drawImage(img, -iw + 1, 0);\n\t      // subsampled image becomes half smaller in rendering size.\n\t      // check alpha channel value to confirm image is covering edge pixel or not.\n\t      // if alpha value is 0 image is not covering, hence subsampled.\n\t      return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Detecting vertical squash in loaded image.\n\t   * Fixes a bug which squash image vertically while drawing into canvas for some images.\n\t   */\n\t  function detectVerticalSquash(img, iw, ih) {\n\t    var canvas = document.createElement('canvas');\n\t    canvas.width = 1;\n\t    canvas.height = ih;\n\t    var ctx = canvas.getContext('2d');\n\t    ctx.drawImage(img, 0, 0);\n\t    var data = ctx.getImageData(0, 0, 1, ih).data;\n\t    // search image edge pixel position in case it is squashed vertically.\n\t    var sy = 0;\n\t    var ey = ih;\n\t    var py = ih;\n\t    while (py > sy) {\n\t      var alpha = data[(py - 1) * 4 + 3];\n\t      if (alpha === 0) {\n\t        ey = py;\n\t      } else {\n\t        sy = py;\n\t      }\n\t      py = (ey + sy) >> 1;\n\t    }\n\t    var ratio = (py / ih);\n\t    return (ratio===0)?1:ratio;\n\t  }\n\t\n\t  /**\n\t   * Rendering image element (with resizing) and get its data URL\n\t   */\n\t  function renderImageToDataURL(img, options, doSquash) {\n\t    var canvas = document.createElement('canvas');\n\t    renderImageToCanvas(img, canvas, options, doSquash);\n\t    return canvas.toDataURL(\"image/jpeg\", options.quality || 0.8);\n\t  }\n\t\n\t  /**\n\t   * Rendering image element (with resizing) into the canvas element\n\t   */\n\t  function renderImageToCanvas(img, canvas, options, doSquash) {\n\t    var iw = img.naturalWidth, ih = img.naturalHeight;\n\t    if (!(iw+ih)) return;\n\t    var width = options.width, height = options.height;\n\t    var ctx = canvas.getContext('2d');\n\t    ctx.save();\n\t    transformCoordinate(canvas, ctx, width, height, options.orientation);\n\t    var subsampled = detectSubsampling(img);\n\t    if (subsampled) {\n\t      iw /= 2;\n\t      ih /= 2;\n\t    }\n\t    var d = 1024; // size of tiling canvas\n\t    var tmpCanvas = document.createElement('canvas');\n\t    tmpCanvas.width = tmpCanvas.height = d;\n\t    var tmpCtx = tmpCanvas.getContext('2d');\n\t    var vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1;\n\t    var dw = Math.ceil(d * width / iw);\n\t    var dh = Math.ceil(d * height / ih / vertSquashRatio);\n\t    var sy = 0;\n\t    var dy = 0;\n\t    while (sy < ih) {\n\t      var sx = 0;\n\t      var dx = 0;\n\t      while (sx < iw) {\n\t        tmpCtx.clearRect(0, 0, d, d);\n\t        tmpCtx.drawImage(img, -sx, -sy);\n\t        ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);\n\t        sx += d;\n\t        dx += dw;\n\t      }\n\t      sy += d;\n\t      dy += dh;\n\t    }\n\t    ctx.restore();\n\t    tmpCanvas = tmpCtx = null;\n\t  }\n\t\n\t  /**\n\t   * Transform canvas coordination according to specified frame size and orientation\n\t   * Orientation value is from EXIF tag\n\t   */\n\t  function transformCoordinate(canvas, ctx, width, height, orientation) {\n\t    switch (orientation) {\n\t      case 5:\n\t      case 6:\n\t      case 7:\n\t      case 8:\n\t        canvas.width = height;\n\t        canvas.height = width;\n\t        break;\n\t      default:\n\t        canvas.width = width;\n\t        canvas.height = height;\n\t    }\n\t    switch (orientation) {\n\t      case 2:\n\t        // horizontal flip\n\t        ctx.translate(width, 0);\n\t        ctx.scale(-1, 1);\n\t        break;\n\t      case 3:\n\t        // 180 rotate left\n\t        ctx.translate(width, height);\n\t        ctx.rotate(Math.PI);\n\t        break;\n\t      case 4:\n\t        // vertical flip\n\t        ctx.translate(0, height);\n\t        ctx.scale(1, -1);\n\t        break;\n\t      case 5:\n\t        // vertical flip + 90 rotate right\n\t        ctx.rotate(0.5 * Math.PI);\n\t        ctx.scale(1, -1);\n\t        break;\n\t      case 6:\n\t        // 90 rotate right\n\t        ctx.rotate(0.5 * Math.PI);\n\t        ctx.translate(0, -height);\n\t        break;\n\t      case 7:\n\t        // horizontal flip + 90 rotate right\n\t        ctx.rotate(0.5 * Math.PI);\n\t        ctx.translate(width, -height);\n\t        ctx.scale(-1, 1);\n\t        break;\n\t      case 8:\n\t        // 90 rotate left\n\t        ctx.rotate(-0.5 * Math.PI);\n\t        ctx.translate(-width, 0);\n\t        break;\n\t      default:\n\t        break;\n\t    }\n\t  }\n\t\n\t  var URL = window.URL && window.URL.createObjectURL ? window.URL :\n\t            window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL :\n\t            null;\n\t\n\t  /**\n\t   * MegaPixImage class\n\t   */\n\t  function MegaPixImage(srcImage) {\n\t    if (window.Blob && srcImage instanceof Blob) {\n\t      if (!URL) { throw Error(\"No createObjectURL function found to create blob url\"); }\n\t      var img = new Image();\n\t      img.src = URL.createObjectURL(srcImage);\n\t      this.blob = srcImage;\n\t      srcImage = img;\n\t    }\n\t    if (!srcImage.naturalWidth && !srcImage.naturalHeight) {\n\t      var _this = this;\n\t      srcImage.onload = srcImage.onerror = function() {\n\t        var listeners = _this.imageLoadListeners;\n\t        if (listeners) {\n\t          _this.imageLoadListeners = null;\n\t          for (var i=0, len=listeners.length; i<len; i++) {\n\t            listeners[i]();\n\t          }\n\t        }\n\t      };\n\t      this.imageLoadListeners = [];\n\t    }\n\t    this.srcImage = srcImage;\n\t  }\n\t\n\t  /**\n\t   * Rendering megapix image into specified target element\n\t   */\n\t  MegaPixImage.prototype.render = function(target, options, callback) {\n\t    if (this.imageLoadListeners) {\n\t      var _this = this;\n\t      this.imageLoadListeners.push(function() { _this.render(target, options, callback); });\n\t      return;\n\t    }\n\t    options = options || {};\n\t    var imgWidth = this.srcImage.naturalWidth, imgHeight = this.srcImage.naturalHeight,\n\t        width = options.width, height = options.height,\n\t        maxWidth = options.maxWidth, maxHeight = options.maxHeight,\n\t        doSquash = !this.blob || this.blob.type === 'image/jpeg';\n\t    if (width && !height) {\n\t      height = (imgHeight * width / imgWidth) << 0;\n\t    } else if (height && !width) {\n\t      width = (imgWidth * height / imgHeight) << 0;\n\t    } else {\n\t      width = imgWidth;\n\t      height = imgHeight;\n\t    }\n\t    if (maxWidth && width > maxWidth) {\n\t      width = maxWidth;\n\t      height = (imgHeight * width / imgWidth) << 0;\n\t    }\n\t    if (maxHeight && height > maxHeight) {\n\t      height = maxHeight;\n\t      width = (imgWidth * height / imgHeight) << 0;\n\t    }\n\t    var opt = { width : width, height : height };\n\t    for (var k in options) opt[k] = options[k];\n\t\n\t    var tagName = target.tagName.toLowerCase();\n\t    if (tagName === 'img') {\n\t      target.src = renderImageToDataURL(this.srcImage, opt, doSquash);\n\t    } else if (tagName === 'canvas') {\n\t      renderImageToCanvas(this.srcImage, target, opt, doSquash);\n\t    }\n\t    if (typeof this.onrender === 'function') {\n\t      this.onrender(target);\n\t    }\n\t    if (callback) {\n\t      callback();\n\t    }\n\t    if (this.blob) {\n\t      this.blob = null;\n\t      URL.revokeObjectURL(this.srcImage.src);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Export class to global\n\t   */\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return MegaPixImage; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // for AMD loader\n\t  } else if (typeof exports === 'object') {\n\t    module.exports = MegaPixImage; // for CommonJS\n\t  } else {\n\t    this.MegaPixImage = MegaPixImage;\n\t  }\n\t\n\t})();\n\n\n/***/ }\n\n});\n\n\n// WEBPACK FOOTER //\n// 1.1.js?v=fb5f58f6093cfaae2ffa","/**\n * Mega pixel image rendering library for iOS6 Safari\n *\n * Fixes iOS6 Safari's image file rendering issue for large size image (over mega-pixel),\n * which causes unexpected subsampling when drawing it in canvas.\n * By using this library, you can safely render the image with proper stretching.\n *\n * Copyright (c) 2012 Shinichi Tomita <shinichi.tomita@gmail.com>\n * Released under the MIT license\n */\n(function() {\n\n  /**\n   * Detect subsampling in loaded image.\n   * In iOS, larger images than 2M pixels may be subsampled in rendering.\n   */\n  function detectSubsampling(img) {\n    var iw = img.naturalWidth, ih = img.naturalHeight;\n    if (iw * ih > 1024 * 1024) { // subsampling may happen over megapixel image\n      var canvas = document.createElement('canvas');\n      canvas.width = canvas.height = 1;\n      var ctx = canvas.getContext('2d');\n      ctx.drawImage(img, -iw + 1, 0);\n      // subsampled image becomes half smaller in rendering size.\n      // check alpha channel value to confirm image is covering edge pixel or not.\n      // if alpha value is 0 image is not covering, hence subsampled.\n      return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Detecting vertical squash in loaded image.\n   * Fixes a bug which squash image vertically while drawing into canvas for some images.\n   */\n  function detectVerticalSquash(img, iw, ih) {\n    var canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = ih;\n    var ctx = canvas.getContext('2d');\n    ctx.drawImage(img, 0, 0);\n    var data = ctx.getImageData(0, 0, 1, ih).data;\n    // search image edge pixel position in case it is squashed vertically.\n    var sy = 0;\n    var ey = ih;\n    var py = ih;\n    while (py > sy) {\n      var alpha = data[(py - 1) * 4 + 3];\n      if (alpha === 0) {\n        ey = py;\n      } else {\n        sy = py;\n      }\n      py = (ey + sy) >> 1;\n    }\n    var ratio = (py / ih);\n    return (ratio===0)?1:ratio;\n  }\n\n  /**\n   * Rendering image element (with resizing) and get its data URL\n   */\n  function renderImageToDataURL(img, options, doSquash) {\n    var canvas = document.createElement('canvas');\n    renderImageToCanvas(img, canvas, options, doSquash);\n    return canvas.toDataURL(\"image/jpeg\", options.quality || 0.8);\n  }\n\n  /**\n   * Rendering image element (with resizing) into the canvas element\n   */\n  function renderImageToCanvas(img, canvas, options, doSquash) {\n    var iw = img.naturalWidth, ih = img.naturalHeight;\n    if (!(iw+ih)) return;\n    var width = options.width, height = options.height;\n    var ctx = canvas.getContext('2d');\n    ctx.save();\n    transformCoordinate(canvas, ctx, width, height, options.orientation);\n    var subsampled = detectSubsampling(img);\n    if (subsampled) {\n      iw /= 2;\n      ih /= 2;\n    }\n    var d = 1024; // size of tiling canvas\n    var tmpCanvas = document.createElement('canvas');\n    tmpCanvas.width = tmpCanvas.height = d;\n    var tmpCtx = tmpCanvas.getContext('2d');\n    var vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1;\n    var dw = Math.ceil(d * width / iw);\n    var dh = Math.ceil(d * height / ih / vertSquashRatio);\n    var sy = 0;\n    var dy = 0;\n    while (sy < ih) {\n      var sx = 0;\n      var dx = 0;\n      while (sx < iw) {\n        tmpCtx.clearRect(0, 0, d, d);\n        tmpCtx.drawImage(img, -sx, -sy);\n        ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);\n        sx += d;\n        dx += dw;\n      }\n      sy += d;\n      dy += dh;\n    }\n    ctx.restore();\n    tmpCanvas = tmpCtx = null;\n  }\n\n  /**\n   * Transform canvas coordination according to specified frame size and orientation\n   * Orientation value is from EXIF tag\n   */\n  function transformCoordinate(canvas, ctx, width, height, orientation) {\n    switch (orientation) {\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n        canvas.width = height;\n        canvas.height = width;\n        break;\n      default:\n        canvas.width = width;\n        canvas.height = height;\n    }\n    switch (orientation) {\n      case 2:\n        // horizontal flip\n        ctx.translate(width, 0);\n        ctx.scale(-1, 1);\n        break;\n      case 3:\n        // 180 rotate left\n        ctx.translate(width, height);\n        ctx.rotate(Math.PI);\n        break;\n      case 4:\n        // vertical flip\n        ctx.translate(0, height);\n        ctx.scale(1, -1);\n        break;\n      case 5:\n        // vertical flip + 90 rotate right\n        ctx.rotate(0.5 * Math.PI);\n        ctx.scale(1, -1);\n        break;\n      case 6:\n        // 90 rotate right\n        ctx.rotate(0.5 * Math.PI);\n        ctx.translate(0, -height);\n        break;\n      case 7:\n        // horizontal flip + 90 rotate right\n        ctx.rotate(0.5 * Math.PI);\n        ctx.translate(width, -height);\n        ctx.scale(-1, 1);\n        break;\n      case 8:\n        // 90 rotate left\n        ctx.rotate(-0.5 * Math.PI);\n        ctx.translate(-width, 0);\n        break;\n      default:\n        break;\n    }\n  }\n\n  var URL = window.URL && window.URL.createObjectURL ? window.URL :\n            window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL :\n            null;\n\n  /**\n   * MegaPixImage class\n   */\n  function MegaPixImage(srcImage) {\n    if (window.Blob && srcImage instanceof Blob) {\n      if (!URL) { throw Error(\"No createObjectURL function found to create blob url\"); }\n      var img = new Image();\n      img.src = URL.createObjectURL(srcImage);\n      this.blob = srcImage;\n      srcImage = img;\n    }\n    if (!srcImage.naturalWidth && !srcImage.naturalHeight) {\n      var _this = this;\n      srcImage.onload = srcImage.onerror = function() {\n        var listeners = _this.imageLoadListeners;\n        if (listeners) {\n          _this.imageLoadListeners = null;\n          for (var i=0, len=listeners.length; i<len; i++) {\n            listeners[i]();\n          }\n        }\n      };\n      this.imageLoadListeners = [];\n    }\n    this.srcImage = srcImage;\n  }\n\n  /**\n   * Rendering megapix image into specified target element\n   */\n  MegaPixImage.prototype.render = function(target, options, callback) {\n    if (this.imageLoadListeners) {\n      var _this = this;\n      this.imageLoadListeners.push(function() { _this.render(target, options, callback); });\n      return;\n    }\n    options = options || {};\n    var imgWidth = this.srcImage.naturalWidth, imgHeight = this.srcImage.naturalHeight,\n        width = options.width, height = options.height,\n        maxWidth = options.maxWidth, maxHeight = options.maxHeight,\n        doSquash = !this.blob || this.blob.type === 'image/jpeg';\n    if (width && !height) {\n      height = (imgHeight * width / imgWidth) << 0;\n    } else if (height && !width) {\n      width = (imgWidth * height / imgHeight) << 0;\n    } else {\n      width = imgWidth;\n      height = imgHeight;\n    }\n    if (maxWidth && width > maxWidth) {\n      width = maxWidth;\n      height = (imgHeight * width / imgWidth) << 0;\n    }\n    if (maxHeight && height > maxHeight) {\n      height = maxHeight;\n      width = (imgWidth * height / imgHeight) << 0;\n    }\n    var opt = { width : width, height : height };\n    for (var k in options) opt[k] = options[k];\n\n    var tagName = target.tagName.toLowerCase();\n    if (tagName === 'img') {\n      target.src = renderImageToDataURL(this.srcImage, opt, doSquash);\n    } else if (tagName === 'canvas') {\n      renderImageToCanvas(this.srcImage, target, opt, doSquash);\n    }\n    if (typeof this.onrender === 'function') {\n      this.onrender(target);\n    }\n    if (callback) {\n      callback();\n    }\n    if (this.blob) {\n      this.blob = null;\n      URL.revokeObjectURL(this.srcImage.src);\n    }\n  };\n\n  /**\n   * Export class to global\n   */\n  if (typeof define === 'function' && define.amd) {\n    define([], function() { return MegaPixImage; }); // for AMD loader\n  } else if (typeof exports === 'object') {\n    module.exports = MegaPixImage; // for CommonJS\n  } else {\n    this.MegaPixImage = MegaPixImage;\n  }\n\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.0.1.3@html5-image-compress/src/libs/megapix-image.js\n// module id = 695\n// module chunks = 1"],"sourceRoot":""}